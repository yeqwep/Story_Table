go.property("drag_threshold", 20)
local cur_data = require("main.cursor.cursor")

function init(self)
  msg.post(".", "acquire_input_focus")
  -- 接触しているオブジェクトのコリジョンIDとグループ
  self.col_id = nil
  self.col_group = nil
  -- 押した判定
  self.pressed = false
	self.released = false
  -- 【オブジェクトのクリックステータステーブル】
  -- オブジェクトがクリックされたか、クリック中のオブジェクトIDとグループ、押した位置
  -- ドラッグしているか、マウスオーバー中のオブジェクトIDとグループ
  self.o = {
    pressed = false,
    pressed_id = nil,
    pressed_group = nil,
    pressed_pos = nil,
    dragging = false,
    over_id = nil,
    over_group = nil,
  }
  self.spos = vmath.vector3(-500 , 0 , 1)
end
-- メッセージ送信1　各オブジェクトへ pressedのみ
local function notify_event1(self, game_object_id, game_object_group, message_id)
  pcall(function()
    -- カーソルメッセージを他のゲームオブジェクトに送る
    msg.post(game_object_id, message_id)
  end)
end
-- メッセージ送信2　カーソルデータへ
local function notify_event2(self, game_object_id, game_object_group, message_id)
    -- カーソルメッセージをカーソルデータに送る
    cur_data.go_id = game_object_id
    cur_data.go_group = game_object_group
    cur_data.go_action = message_id
end
-- メッセージ送信3　カーソルデータへ
local function notify_event3(self, game_object_id, game_object_group)
    -- カーソルメッセージをカーソルデータに送る
    cur_data.over_id = game_object_id
    cur_data.over_group = game_object_group
end
-- マルチタッチ数計算
local function multi_touch(self, action_id, action)
  local t = 0
  for i, tpoint in ipairs(action.touch) do
    t = t + 1
  end
  return t
end
-- マウスクリック判定
local function handle_input(self, action_id, action)
  local t = 0
  -- -- マルチタッチした時、マルチタッチ数計算
  if action_id == hash("multi") then
    t = (multi_touch(self, action_id, action))
  end

	if not action_id or action_id == hash("touch") or t == 1 then
		if action.pressed then
			self.pressed = true
		elseif action.released then
			self.released = true
		end
	end
end

function update(self, dt)
  -- ドラッグ対象の位置
  local c_pos = go.get_position()
  -- クリック時
  if self.pressed then
    -- クリックフラグfalseかつオブジェクトにのってるとき一度発生
    if not self.o.pressed and self.o.over_id then
      -- クリックフラグをtrueにする
      self.o.pressed = true
      -- オブジェクトのIDをクリック中のIDとして登録（グループも）
      self.o.pressed_id = self.o.over_id
      self.o.pressed_group = self.o.over_group
      -- 現在のクリック位置を保存
      self.o.pressed_pos = go.get_position()
      -- オブジェクトに「pressed」メッセージ送る
      notify_event1(self, self.o.pressed_id, self.o.pressed_group, "pressed")
    end
    -- ドラッグ開始
    self.dragging = true
    -- クリック離したとき オブジェクトがクリックされていた時
  elseif self.released and self.o.pressed then
    -- ドラックしていた時
    if self.o.dragging then
      -- ドラッグ終了
      self.o.dragging = false
      -- カーソルデータに「drag_end」メッセージ送る
      -- notify_event2(self, self.o.pressed_id, self.o.pressed_group, "drag_end")
    end
    -- クリックフラグfalse
    self.o.pressed = false
    -- クリックオブジェクトのIDとグループ消す
    self.o.pressed_id = nil
    self.o.pressed_group = nil
  end
  -- カーソルオーバーIDがあり、カーソルオーバーIDがコリジョンIDと違うとき
  -- （別のオブジェクトに移った、コリジョン離れた）
  if self.o.over_id and self.o.over_id ~= self.col_id and self.o.pressed == false then
    -- オーバーIDを消す
    self.o.over_id = nil
    self.o.over_group = nil
    --  カーソルデータのover_id　消す
    -- notify_event3(self, self.o.over_id, self.o.over_group)
  end
  -- コリジョンIDがあり、カーソルオーバーIDがコリジョンIDと違うとき
  if self.col_id and self.o.over_id ~= self.col_id and self.o.pressed == false then
    -- コリジョンで接触してるIDをover_idに記録
    self.o.over_id = self.col_id
    self.o.over_group = self.col_group
    --  カーソルデータにover_idを送る
    -- notify_event3(self, self.o.over_id, self.o.over_group)
  end
  --オブジェクトクリックされていてドラッグされていないとき
  if self.o.pressed and not self.o.dragging then
    local d = vmath.length(c_pos - self.o.pressed_pos)
    -- クリック開始位置からドラッグ判定プロパティ以上の距離離れたときドラッグステータスオン
    if d >= self.drag_threshold then
      self.o.dragging = true
      --  カーソルデータに「drag_start」メッセージ送る
      -- notify_event2(self, self.o.pressed_id, self.o.pressed_group, "drag_start")
    end
  end
  -- 常にコリジョンID、グループ消す
  self.col_id = nil
  self.col_group = nil
  self.pressed = false
  self.released = false
end

function on_message(self, message_id, message, sender)
  -- コリジョン接触中
  if message_id == hash("collision_response") then
    -- コリジョンIDまだない、もしくはすでに触っているオブジェクトのZ位置が他より小さい（奥にある）時
    -- 別のオブジェクトにフォーカス other_position、other_id、other_group=コリジョンリスポンの変数
    if not self.col_id or go.get_position(self.col_id).z < message.other_position.z then
      self.col_id = message.other_id
      self.col_group = message.other_group
    end
  end
end

function on_input(self, action_id, action)
  if action.x ~= nil then
    self.spos.x = action.x
    self.spos.y = action.y
  end
  go.set_position(self.spos)
  -- 入力判定
  handle_input(self, action_id, action)
end
